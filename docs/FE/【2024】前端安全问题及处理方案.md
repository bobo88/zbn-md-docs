# 前端常见安全问题及处理方案

**时间：** 2024.12.26

在前后端 API 交互联调过程中，常常会涉及到一些项目的安全问题，在前端侧，如何进行规避和处理这些问题，尽可能的把问题提前暴露出来并提升用户的使用体验。

整理常见的问题，并分类列举如下：

## 前端常用安全问题总结

1. **输入验证与处理：** 前端对与后端进行交互的数据进行验证和处理（包括字符长度、类型、文件大小等），防止恶意输入导致的安全问题。

   - **核心点：** 不符合要求的数据，过滤掉，给出前端验证反馈（提升用户体验），不传给后端。

2. **数据传输：** 前端与后端进行数据传输时（不要使用硬编码将项目敏感信息泄露），需要确保数据的安全性，防止数据被窃取或篡改。

   - **核心点：** 敏感信息，不要直接传输，需要加密。

3. **身份认证与授权：** 前端需要与后端进行身份认证和授权，确保只有合法用户才能访问敏感信息或执行敏感操作。

   - **核心点：** 资源谁能访问，怎么访问，访问权限要严格控制（由后端配置）。

4. **请求限制：** 前端需要限制请求次数，防止恶意请求导致的服务器压力。
   - **核心点：** 限制请求次数，防止恶意请求（比如：不能重复提交表单等）。

---

基于 **输入验证与处理、数据传输、身份认证与授权、请求限制** 的四个核心安全点，在 Vue 3 项目中可以通过以下代码示例来实现安全设计：

## 一、输入验证与处理

**实现目标：** 确保用户输入数据符合预期格式，防止 XSS、SQL 注入、命令注入等问题。

```vue
<template>
  <form @submit.prevent="handleSubmit">
    <input v-model="username" type="text" maxlength="20" placeholder="Enter your username" />
    <input v-model="email" type="email" placeholder="Enter your email" />
    <button type="submit">Submit</button>
  </form>
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const username = ref('');
    const email = ref('');

    const handleSubmit = () => {
      // 1. 前端验证输入
      if (!/^[a-zA-Z0-9]{3,20}$/.test(username.value)) {
        alert('Invalid username. Use 3-20 alphanumeric characters.');
        return;
      }
      if (!/^\S+@\S+\.\S+$/.test(email.value)) {
        alert('Invalid email format.');
        return;
      }

      // 2. 数据发送到后端
      const payload = {
        username: username.value.trim(),
        email: email.value.trim(),
      };

      fetch('/api/submit', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });
    };

    return { username, email, handleSubmit };
  },
};
</script>
```

**关键点：**

- 使用正则表达式和 `maxlength` 限制输入内容。
- 对输入数据进行 `trim` 去除多余空格。
- 在提交给后端之前再次验证。

---

## 二、数据传输

**实现目标：** 加密敏感信息，防止数据被窃取或篡改。

```javascript
// utils/encryption.js
import CryptoJS from 'crypto-js';

// 对敏感数据进行加密
export const encryptData = (data, secretKey) => {
  return CryptoJS.AES.encrypt(JSON.stringify(data), secretKey).toString();
};

// 解密数据
export const decryptData = (encryptedData, secretKey) => {
  const bytes = CryptoJS.AES.decrypt(encryptedData, secretKey);
  return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
};
```

```vue
<script>
import { encryptData } from '@/utils/encryption';

export default {
  setup() {
    const secretKey = 'your-secret-key'; // 建议从后端获取

    const sendData = async () => {
      const sensitiveData = { creditCard: '1234-5678-9876-5432', cvv: '123' };
      const encryptedPayload = encryptData(sensitiveData, secretKey);

      await fetch('/api/secure-endpoint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ data: encryptedPayload }),
      });
    };

    return { sendData };
  },
};
</script>
```

**关键点：**

- 敏感数据通过 AES 加密后传输。
- 后端解密后再处理敏感信息。

---

## 三、身份认证与授权

**实现目标：** 使用 Token 验证用户身份，限制访问权限。

```javascript
// api/auth.js
import axios from 'axios';

const apiClient = axios.create({
  baseURL: '/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// 添加请求拦截器（附加 Token）
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 用户登录
export const login = async (credentials) => {
  const response = await apiClient.post('/login', credentials);
  const token = response.data.token;
  localStorage.setItem('authToken', token); // 存储 Token
  return token;
};

// 获取用户信息
export const getUserInfo = async () => {
  return await apiClient.get('/user');
};
```

```vue
<script>
import { login, getUserInfo } from '@/api/auth';

export default {
  setup() {
    const handleLogin = async () => {
      try {
        const token = await login({ username: 'user', password: 'pass' });
        console.log('Logged in successfully, token:', token);

        // 获取用户信息
        const userInfo = await getUserInfo();
        console.log('User info:', userInfo.data);
      } catch (error) {
        console.error('Login failed:', error);
      }
    };

    return { handleLogin };
  },
};
</script>
```

**关键点：**

- 使用 `localStorage` 或 `sessionStorage` 存储 Token。
- 在 API 请求中通过拦截器自动附加 Token。

---

## 四、请求限制

**实现目标：** 防止恶意请求（如暴力破解、DoS 攻击）。

```vue
<script>
import axios from 'axios';
import _ from 'lodash';

export default {
  setup() {
    // 限制请求频率
    const rateLimitedFetch = _.throttle(async () => {
      try {
        const response = await axios.get('/api/rate-limited-endpoint');
        console.log(response.data);
      } catch (error) {
        console.error('Request failed:', error);
      }
    }, 3000); // 每 3 秒允许发送一次请求

    return { rateLimitedFetch };
  },
};
</script>
```

**关键点：**

- 使用 `lodash` 的 `throttle` 或 `debounce` 限制请求频率。
- 服务端同样需要配合限流策略（如 Redis 记录用户请求频率）。
- 或者使用 `flag` 标志，限制同一时间段的用户操作行为（如重复点击提交按钮等）。
